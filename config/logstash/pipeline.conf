input {
  beats {
    port => 5044
  }
  
  tcp {
    port => 5000
    codec => json_lines
  }
}

filter {
  # Docker logs come as: {"log":"{...app JSON...}\n","stream":"stdout","time":"..."}
  # Filebeat extracts: log (string with app JSON), stream, time
  # We need to parse the app JSON from the log/message field
  
  # Priority 1: Check event.original (raw Docker log line)
  if [event][original] {
    json {
      source => "[event][original]"
      target => "docker_raw"
    }
    if [docker_raw][log] {
      # Clean the log field - remove trailing newline
      mutate {
        gsub => [ "[docker_raw][log]", "\n", "" ]
      }
      if [docker_raw][log] =~ /^\{.*\}$/ {
        # Docker log field contains JSON, parse it
        json {
          source => "[docker_raw][log]"
          target => "app_log"
        }
        if [app_log] and [app_log][message] {
          # Extract message from app_log - handle if it's array or string
          if [app_log][message][0] {
            mutate {
              add_field => { "message" => "%{[app_log][message][0]}" }
            }
          } else {
            mutate {
              add_field => { "message" => "%{[app_log][message]}" }
            }
          }
          mutate {
            add_field => { "level" => "%{[app_log][level]}" }
            add_field => { "service" => "%{[app_log][service]}" }
            copy => { "[app_log][timestamp]" => "app_timestamp" }
            copy => { "[app_log][order_id]" => "order_id" }
            copy => { "[app_log][customer_id]" => "customer_id" }
            copy => { "[app_log][operation]" => "operation" }
          }
        } else {
          mutate {
            add_field => { "message" => "%{[docker_raw][log]}" }
          }
        }
      } else {
        mutate {
          add_field => { "message" => "%{[docker_raw][log]}" }
        }
      }
    }
  }
  
  # Priority 2: Try message field (if Filebeat already extracted)
  if [message] {
    if [message] =~ /^\{.*\}$/ and ![app_log] {
      # Message is JSON and not parsed yet
      json {
        source => "message"
        target => "app_log"
      }
      if [app_log] {
        mutate {
          replace => { "message" => "%{[app_log][message]}" }
          add_field => { "level" => "%{[app_log][level]}" }
          add_field => { "service" => "%{[app_log][service]}" }
          copy => { "[app_log][timestamp]" => "app_timestamp" }
          copy => { "[app_log][order_id]" => "order_id" }
          copy => { "[app_log][customer_id]" => "customer_id" }
          copy => { "[app_log][operation]" => "operation" }
        }
      }
    }
  }
  
  # Priority 3: Try log field (if still available, but might be file metadata)
  if ![message] {
    # Check if log is a string (content) or object (metadata)
    if [log][offset] {
      # log is metadata object, skip it
    } else if [log] {
      # Check if log is a JSON string
      if [log] =~ /^\{.*\}$/ {
        # log is JSON string, parse it
        json {
          source => "log"
          target => "app_log"
        }
        if [app_log] {
          mutate {
            add_field => { "message" => "%{[app_log][message]}" }
            add_field => { "level" => "%{[app_log][level]}" }
            add_field => { "service" => "%{[app_log][service]}" }
          }
        }
      } else {
        # log is plain text, use as message
        mutate {
          add_field => { "message" => "%{log}" }
        }
      }
    }
  }
  
  # Add timestamp if not present
  if ![timestamp] {
    mutate {
      add_field => { "timestamp" => "%{@timestamp}" }
    }
  }
  
  # Parse trace_id and span_id for correlation
  if [trace_id] {
    mutate {
      add_field => { "trace_id" => "%{trace_id}" }
    }
  }
  
  if [span_id] {
    mutate {
      add_field => { "span_id" => "%{span_id}" }
    }
  }
  
  # Add service name based on container name or docker compose service label
  if [container] {
    # Try docker compose service label first
    if [container][labels][com_docker_compose_service] {
      mutate {
        add_field => { "service_name" => "%{[container][labels][com_docker_compose_service]}" }
      }
    }
    # Fallback to container name (without prefix)
    else if [container][name] {
      if [container][name] =~ /orders.*api/ {
        mutate {
          add_field => { "service_name" => "orders-api" }
        }
      } else if [container][name] =~ /payment/ {
        mutate {
          add_field => { "service_name" => "payment-service" }
        }
      } else if [container][name] =~ /inventory/ {
        mutate {
          add_field => { "service_name" => "inventory-service" }
        }
      } else if [container][name] =~ /notification/ {
        mutate {
          add_field => { "service_name" => "notification-service" }
        }
      } else if [container][name] =~ /aggregator/ {
        mutate {
          add_field => { "service_name" => "aggregator-service" }
        }
      } else if [container][name] =~ /outbox/ {
        mutate {
          add_field => { "service_name" => "outbox-dispatcher" }
        }
      }
    }
  }
  
  # Fallback: try source field if container metadata not available
  if ![service_name] {
    if [source] =~ /orders/ {
      mutate {
        add_field => { "service_name" => "orders-api" }
      }
    } else if [source] =~ /payment/ {
      mutate {
        add_field => { "service_name" => "payment-service" }
      }
    } else if [source] =~ /inventory/ {
      mutate {
        add_field => { "service_name" => "inventory-service" }
      }
    } else if [source] =~ /notification/ {
      mutate {
        add_field => { "service_name" => "notification-service" }
      }
    } else if [source] =~ /aggregator/ {
      mutate {
        add_field => { "service_name" => "aggregator-service" }
      }
    } else if [source] =~ /outbox/ {
      mutate {
        add_field => { "service_name" => "outbox-dispatcher" }
      }
    }
  }
  
  # Parse log level
  if [level] {
    mutate {
      add_field => { "log_level" => "%{level}" }
    }
  }
  
  # Parse HTTP request information
  if [http] {
    mutate {
      add_field => { "http_method" => "%{[http][method]}" }
      add_field => { "http_path" => "%{[http][path]}" }
      add_field => { "http_status" => "%{[http][status]}" }
      add_field => { "response_time_ms" => "%{[http][response_time_ms]}" }
    }
  }
  
  # Parse RabbitMQ information
  if [rabbitmq] {
    mutate {
      add_field => { "queue_name" => "%{[rabbitmq][queue]}" }
      add_field => { "exchange_name" => "%{[rabbitmq][exchange]}" }
      add_field => { "routing_key" => "%{[rabbitmq][routing_key]}" }
    }
  }
  
  # Parse database information
  if [database] {
    mutate {
      add_field => { "db_operation" => "%{[database][operation]}" }
      add_field => { "db_table" => "%{[database][table]}" }
      add_field => { "db_duration_ms" => "%{[database][duration_ms]}" }
    }
  }
  
  # Parse business metrics
  if [metrics] {
    mutate {
      add_field => { "order_id" => "%{[metrics][order_id]}" }
      add_field => { "customer_id" => "%{[metrics][customer_id]}" }
      add_field => { "product_id" => "%{[metrics][product_id]}" }
      add_field => { "amount" => "%{[metrics][amount]}" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "order-process-logs-%{+YYYY.MM.dd}"
  }
  
  # Debug output (remove in production)
  stdout {
    codec => rubydebug
  }
}

